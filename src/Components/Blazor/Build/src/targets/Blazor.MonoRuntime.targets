<Project>
  <PropertyGroup>
    <BlazorLinkOnBuild Condition="$(BlazorLinkOnBuild) == ''">true</BlazorLinkOnBuild>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Stop-gap until we can migrate Blazor.Mono package to use better naming convention -->
    <DotNetWebAssemblyBCLPath Condition="'$(DotNetWebAssemblyBCLPath)' == '' AND '$(MonoBaseClassLibraryPath)' != ''">$(MonoBaseClassLibraryPath)</DotNetWebAssemblyBCLPath>
    <DotNetWebAssemblyBCLFacadesPath Condition="'$(DotNetWebAssemblyBCLFacadesPath)' == '' AND '$(MonoBaseClassLibraryFacadesPath)' != ''">$(MonoBaseClassLibraryFacadesPath)</DotNetWebAssemblyBCLFacadesPath>
    <DotNetWebAssemblyRuntimePath Condition="'$(DotNetWebAssemblyRuntimePath)' == '' AND '$(MonoWasmRuntimePath)' != ''">$(MonoWasmRuntimePath)</DotNetWebAssemblyRuntimePath>
    <DotNetWebAssemblyFrameworkPath Condition="'$(DotNetWebAssemblyFrameworkPath)' == '' AND '$(MonoWasmFrameworkPath)' != ''">$(MonoWasmFrameworkPath)</DotNetWebAssemblyFrameworkPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(DotNetWebAssemblyArtifactsRoot)' != ''">
    <!-- Compute paths given a path to DotNet WASM artifacts. This is meant to make it easy to test WASM builds -->
    <DotNetWebAssemblyBCLPath>$(DotNetWebAssemblyArtifactsRoot)\wasm-bcl\wasm\</DotNetWebAssemblyBCLPath>
    <DotNetWebAssemblyBCLFacadesPath>$(DotNetWebAssemblyBCLPath)\Facades\</DotNetWebAssemblyBCLFacadesPath>
    <DotNetWebAssemblyRuntimePath>$(DotNetWebAssemblyArtifactsRoot)\builds\debug\</DotNetWebAssemblyRuntimePath>
    <DotNetWebAssemblyFrameworkPath>$(DotNetWebAssemblyArtifactsRoot)\framework\</DotNetWebAssemblyFrameworkPath>
  </PropertyGroup>

  <Target
    Name="_BlazorCopyFilesToOutputDirectory"
    DependsOnTargets="PrepareBlazorOutputs"
    Inputs="@(BlazorOutputWithTargetPath)"
    Outputs="@(BlazorOutputWithTargetPath->'$(TargetDir)%(TargetOutputPath)')"
    AfterTargets="CopyFilesToOutputDirectory"
    Condition="'$(OutputType.ToLowerInvariant())'=='exe'">

    <!-- Copy the blazor output files  -->
    <Copy
      SourceFiles="@(BlazorOutputWithTargetPath)"
      DestinationFiles="@(BlazorOutputWithTargetPath->'$(TargetDir)%(TargetOutputPath)')"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)"
      Condition="'@(BlazorOutputWithTargetPath)' != '' and '$(CopyBuildOutputToOutputDirectory)' == 'true' and '$(SkipCopyBuildProduct)' != 'true'">
    </Copy>

    <ItemGroup>
      <FileWrites Include="@(BlazorOutputWithTargetPath->'$(TargetDir)%(TargetOutputPath)')" />
    </ItemGroup>

    <ItemGroup>
      <_BlazorStatisticsOutput Include="@(BlazorOutputWithTargetPath->'%(TargetOutputPath)')" />
    </ItemGroup>

    <Message Importance="high" Text="$(TargetName) (Blazor output) -> $(TargetDir)dist" />
  </Target>

  <Target
    Name="PrepareBlazorOutputs"
    DependsOnTargets="_ResolveBlazorInputs;_ResolveBlazorOutputs;_GenerateBlazorBootJson">

    <ItemGroup>
      <MonoWasmFile Include="$(DotNetWebAssemblyRuntimePath)*" />
      <BlazorJSFile Include="$(BlazorJSPath)" />
      <BlazorJSFile Include="$(BlazorJSMapPath)" Condition="Exists('$(BlazorJSMapPath)')" />

      <BlazorOutputWithTargetPath Include="@(MonoWasmFile)">
        <TargetOutputPath>$(BlazorRuntimeWasmOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
      <BlazorOutputWithTargetPath Include="@(BlazorJSFile)">
        <TargetOutputPath>$(BaseBlazorRuntimeOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
    </ItemGroup>

    <ItemGroup Label="Static content supplied by NuGet packages">
      <_BlazorPackageContentOutput Include="@(BlazorPackageContentFile)" Condition="%(SourcePackage) != ''">
        <TargetOutputPath>$(BaseBlazorPackageContentOutputPath)%(SourcePackage)\%(RecursiveDir)\%(Filename)%(Extension)</TargetOutputPath>
      </_BlazorPackageContentOutput>
      <BlazorOutputWithTargetPath Include="@(_BlazorPackageContentOutput)" />
    </ItemGroup>
  </Target>

  <Target Name="_ResolveBlazorInputs">
    <PropertyGroup>
      <!-- /obj/<<configuration>>/<<targetframework>>/blazor -->
      <BlazorIntermediateOutputPath>$(IntermediateOutputPath)blazor\</BlazorIntermediateOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker.descriptor.xml -->
      <GeneratedBlazorLinkerDescriptor>$(BlazorIntermediateOutputPath)linker.descriptor.xml</GeneratedBlazorLinkerDescriptor>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/linker/ -->
      <BlazorIntermediateLinkerOutputPath>$(BlazorIntermediateOutputPath)linker/</BlazorIntermediateLinkerOutputPath>

      <!-- /obj/<<configuration>>/<<targetframework>>/blazor/blazor.boot.json -->
      <BlazorBootJsonIntermediateOutputPath>$(BlazorIntermediateOutputPath)$(BlazorBootJsonName)</BlazorBootJsonIntermediateOutputPath>

      <_BlazorLinkerOutputCache>$(BlazorIntermediateOutputPath)linker.output</_BlazorLinkerOutputCache>

      <_BlazorApplicationAssembliesCacheFile>$(BlazorIntermediateOutputPath)unlinked.output</_BlazorApplicationAssembliesCacheFile>
    </PropertyGroup>

    <ItemGroup>
      <_BlazorDependencyInput Include="@(ReferenceCopyLocalPaths->WithMetadataValue('Extension','.dll')->'%(FullPath)')" />

      <_WebAssemblyBCLFolder Include="
        $(DotNetWebAssemblyBCLPath);
        $(DotNetWebAssemblyBCLFacadesPath);
        $(DotNetWebAssemblyFrameworkPath)" />

      <_WebAssemblyBCLAssembly Include="%(_WebAssemblyBCLFolder.Identity)*.dll" />
    </ItemGroup>

    <MakeDir Directories="$(BlazorIntermediateOutputPath)" />
  </Target>

  <Target Name="_ResolveBlazorOutputs" DependsOnTargets="_ResolveBlazorOutputsWhenLinked;_ResolveBlazorOutputsWhenNotLinked">
    <Error
      Message="Unrecongnized value for BlazorLinkOnBuild: '$(BlazorLinkOnBuild)'. Valid values are 'true' or 'false'."
      Condition="'$(BlazorLinkOnBuild)' != 'true' AND '$(BlazorLinkOnBuild)' != 'false'" />

    <!-- _BlazorLinkerOutputCache records files linked during the last incremental build of the target. Read the contents and assign linked files to be copied to the output. -->
    <ReadLinesFromFile File="$(_BlazorLinkerOutputCache)">
      <Output TaskParameter="Lines" ItemName="_BlazorLinkedFile"/>
    </ReadLinesFromFile>

    <ItemGroup>
      <BlazorOutputWithTargetPath Include="%(_BlazorLinkedFile.Identity)">
        <TargetOutputPath>$(BlazorRuntimeBinOutputPath)%(FileName)%(Extension)</TargetOutputPath>
      </BlazorOutputWithTargetPath>
    </ItemGroup>
  </Target>

  <!--
  Linker enabled part of the pipeline:

  * If there are no descriptors defined, generate a new linker descriptor.
  * Invoke the linker and write linked files to a well-known directory.
  * Collect the outputs of the linker.
  -->

  <Target
    Name="_ResolveBlazorOutputsWhenLinked"
    Condition="'$(BlazorLinkOnBuild)' == 'true'"
    DependsOnTargets="_GenerateBlazorLinkerDescriptor;_LinkBlazorApplication">
  </Target>

  <UsingTask TaskName="BlazorCreateRootDescriptorFile" AssemblyFile="$(BlazorTasksPath)" />
  <Target Name="_GenerateBlazorLinkerDescriptor"
          Inputs="@(IntermediateAssembly)"
          Outputs="$(GeneratedBlazorLinkerDescriptor)"
          Condition="'@(BlazorLinkerDescriptor)' == ''">

    <!-- Generate linker descriptors if the project doesn't explicitly provide one. -->

    <BlazorCreateRootDescriptorFile
      AssemblyNames="@(IntermediateAssembly->'%(Filename)')"
      RootDescriptorFilePath="$(GeneratedBlazorLinkerDescriptor)" />

    <ItemGroup>
      <FileWrites Include="$(GeneratedBlazorLinkerDescriptor)" />
      <BlazorLinkerDescriptor Include="$(GeneratedBlazorLinkerDescriptor)" />
      <BlazorLinkerDescriptor Include="$(_BlazorBuiltInBclLinkerDescriptor)" />
    </ItemGroup>
  </Target>

  <UsingTask TaskName="BlazorILLink" AssemblyFile="$(BlazorTasksPath)" />

  <Target
      Name="_LinkBlazorApplication"
      Inputs="$(ProjectAssetsFile);
              @(IntermediateAssembly);
              @(_BlazorDependencyInput);
              @(BlazorLinkerDescriptor);
              $(MSBuildAllProjects)"
      Outputs="$(_BlazorLinkerOutputCache)">

    <ItemGroup>
      <_BlazorDependencyAssembly Include="@(_BlazorDependencyInput)" IsLinkable="$([System.String]::Copy('%(FileName)').StartsWith('System.'))" />

      <_BlazorAssemblyToLink Include="@(_WebAssemblyBCLAssembly)" />
      <_BlazorAssemblyToLink Include="@(_BlazorDependencyAssembly)" Condition="'%(_BlazorDependencyAssembly.IsLinkable)' == 'true'" />

      <_BlazorLinkerRoot Include="@(IntermediateAssembly)" />
      <_BlazorLinkerRoot Include="@(_BlazorDependencyAssembly)" Condition="'%(_BlazorDependencyAssembly.IsLinkable)' != 'true'" />
    </ItemGroup>

    <PropertyGroup>
      <_BlazorLinkerAdditionalOptions>-l $(MonoLinkerI18NAssemblies) $(AdditionalMonoLinkerOptions)</_BlazorLinkerAdditionalOptions>
    </PropertyGroup>

    <ItemGroup>
      <_OldLinkedFile Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
      <_OldLinkedFile Include="$(BlazorIntermediateLinkerOutputPath)*.pdb" />
    </ItemGroup>

    <Delete Files="@(_OldLinkedFile)" />

    <!--
      When running from Desktop MSBuild, DOTNET_HOST_PATH is not set.
      In this case, explicitly specify the path to the dotnet host.
    -->
    <PropertyGroup Condition=" '$(DOTNET_HOST_PATH)' == '' ">
      <_DotNetHostDirectory>$(NetCoreRoot)</_DotNetHostDirectory>
      <_DotNetHostFileName>dotnet</_DotNetHostFileName>
      <_DotNetHostFileName Condition=" '$(OS)' == 'Windows_NT' ">dotnet.exe</_DotNetHostFileName>
    </PropertyGroup>

    <BlazorILLink
        ILLinkPath="$(MonoLinkerPath)"
        AssemblyPaths="@(_BlazorAssemblyToLink)"
        RootAssemblyNames="@(_BlazorLinkerRoot)"
        RootDescriptorFiles="@(BlazorLinkerDescriptor)"
        OutputDirectory="$(BlazorIntermediateLinkerOutputPath)"
        ExtraArgs="$(_BlazorLinkerAdditionalOptions)"
        ToolExe="$(_DotNetHostFileName)"
        ToolPath="$(_DotNetHostDirectory)" />

    <ItemGroup>
      <_LinkerResult Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
      <_LinkerResult Include="$(BlazorIntermediateLinkerOutputPath)*.pdb" Condition="'$(BlazorEnableDebugging)' == 'true'" />
    </ItemGroup>

    <WriteLinesToFile File="$(_BlazorLinkerOutputCache)" Lines="@(_LinkerResult)" Overwrite="true" />
  </Target>

  <UsingTask TaskName="BlazorGetAssemblyReferences" AssemblyFile="$(BlazorTasksPath)" />

  <Target Name="_GetBlazorNotLinkedInputs">
    <!--
    We're using ILLink to determine the minimum closure of assemblies that need to be copied to the output directory. However executing ILLink results in a separate process being launched.
    The outputs of a previous run are
    -->

    <PropertyGroup>
      <_BlazorReferenceCacheFile>$(BlazorIntermediateOutputPath)blazor.assemblyreferences.cache</_BlazorReferenceCacheFile>
    </PropertyGroup>

    <ItemGroup>
      <_BlazorProjectReference Include="@(ReferencePath->WithMetadataValue('ReferenceSourceTarget', 'ProjectReference'))" />
      <_BlazorExternalReference Include="@(ReferencePath)" Exclude="@(_BlazorProjectReference)" />
    </ItemGroup>

    <BlazorGetAssemblyReferences Assemblies="@(IntermediateAssembly);@(_BlazorProjectReference)">
      <Output TaskParameter="AssemblyReferences" ItemName="_ProjectAssemblyReferences" />
    </BlazorGetAssemblyReferences>

    <Hash ItemsToHash="@(_BlazorProjectReference);@(_ProjectAssemblyReferences);">
      <Output TaskParameter="HashResult" PropertyName="_BlazorReferenceHash" />
    </Hash>

    <WriteLinesToFile
      Lines="$(_BlazorReferenceHash)"
      File="$(_BlazorReferenceCacheFile)"
      Overwrite="True"
      WriteOnlyWhenDifferent="True" />
  </Target>

  <Target
    Name="_GetBlazorNotLinkedAssemblyClosure"
    DependsOnTargets="_GenerateBlazorLinkerDescriptor"
    Inputs="$(ProjectAssetsFile);
            $(_BlazorReferenceCacheFile);
            @(_BlazorExternalReference);"
    Outputs="$(_BlazorLinkerOutputCache)">

   <ItemGroup>
      <_OldLinkedFile Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
      <_OldLinkedFile Include="$(BlazorIntermediateLinkerOutputPath)*.pdb" />
    </ItemGroup>

    <Delete Files="@(_OldLinkedFile)" />

    <!--
      When running from Desktop MSBuild, DOTNET_HOST_PATH is not set.
      In this case, explicitly specify the path to the dotnet host.
    -->
    <PropertyGroup Condition=" '$(DOTNET_HOST_PATH)' == '' ">
      <_DotNetHostDirectory>$(NetCoreRoot)</_DotNetHostDirectory>
      <_DotNetHostFileName>dotnet</_DotNetHostFileName>
      <_DotNetHostFileName Condition=" '$(OS)' == 'Windows_NT' ">dotnet.exe</_DotNetHostFileName>
    </PropertyGroup>

    <BlazorILLink
        ILLinkPath="$(MonoLinkerPath)"
        AssemblyPaths="@(_BlazorDependencyInput);@(_WebAssemblyBCLAssembly)"
        RootAssemblyNames="@(IntermediateAssembly)"
        RootDescriptorFiles="@(BlazorLinkerDescriptor)"
        OutputDirectory="$(BlazorIntermediateLinkerOutputPath)"
        ExtraArgs="$(_BlazorLinkerAdditionalOptions)"
        ToolExe="$(_DotNetHostFileName)"
        ToolPath="$(_DotNetHostDirectory)"
        FrameworkAssemblyAction="copyused" />

    <ItemGroup>
      <_LinkerResult Include="$(BlazorIntermediateLinkerOutputPath)*.dll" />
      <_LinkerResult Include="$(BlazorIntermediateLinkerOutputPath)*.pdb" Condition="'$(BlazorEnableDebugging)' == 'true'" />
    </ItemGroup>

    <WriteLinesToFile File="$(_BlazorLinkerOutputCache)" Lines="@(_LinkerResult)" Overwrite="true" />

    <ItemGroup>
      <FileWrites Include="$(_BlazorLinkerOutputCache)" />
    </ItemGroup>
  </Target>

  <Target
    Name="_ResolveBlazorOutputsWhenNotLinked"
    Condition="'$(BlazorLinkOnBuild)' != 'true'"
    DependsOnTargets="_GetBlazorNotLinkedInputs;_GetBlazorNotLinkedAssemblyClosure">

    <!--
      _GetBlazorNotLinkedAssemblyClosure might have been skipped due to build incrementalism. However, the IntermediateAssembly or assemblies produced
      by project references may be newer. Copy them to the linker output directory.
    -->

    <Copy
      SourceFiles="@(IntermediateAssembly);@(_BlazorProjectReference)"
      DestinationFolder="$(BlazorIntermediateLinkerOutputPath)"
      SkipUnchangedFiles="$(SkipCopyUnchangedFiles)"
      OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
      Retries="$(CopyRetryCount)"
      RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
      UseHardlinksIfPossible="$(CreateHardLinksForCopyFilesToOutputDirectoryIfPossible)"
      UseSymboliclinksIfPossible="$(CreateSymbolicLinksForCopyFilesToOutputDirectoryIfPossible)">

      <Output TaskParameter="CopiedFiles" ItemName="FileWrites" />
    </Copy>
  </Target>

  <UsingTask TaskName="GenerateBlazorBootJson" AssemblyFile="$(BlazorTasksPath)" />

  <Target
    Name="_GenerateBlazorBootJson"
    Inputs="@(BlazorOutputWithTargetPath)"
    Outputs="$(BlazorBootJsonIntermediateOutputPath)">
    <ItemGroup>
      <_AppReferences Include="@(BlazorOutputWithTargetPath->WithMetadataValue('Extension','.dll'))" />
      <_AppReferences Include="@(BlazorOutputWithTargetPath->WithMetadataValue('Extension','.pdb'))" Condition="'$(BlazorEnableDebugging)' == 'true'" />
    </ItemGroup>

    <GenerateBlazorBootJson
      AssemblyPath="@(IntermediateAssembly)"
      References="@(_AppReferences)"
      LinkerEnabled="$(BlazorLinkOnBuild)"
      OutputPath="$(BlazorBootJsonIntermediateOutputPath)" />

    <ItemGroup>
      <BlazorOutputWithTargetPath Include="$(BlazorBootJsonIntermediateOutputPath)" TargetOutputPath="$(BaseBlazorRuntimeOutputPath)$(BlazorBootJsonName)" />
      <FileWrites Include="$(BlazorBootJsonIntermediateOutputPath)" />
    </ItemGroup>
  </Target>

</Project>
